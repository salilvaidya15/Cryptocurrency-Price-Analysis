{
    "collab_server" : "",
    "contents" : "function(input, output, session){\n  #compute the bin sizes from the number of bins\n  compute_bins <- function(x, n) {\n    list(\n      start = min(x),\n      end = max(x),\n      size = (max(x) - min(x)) / n\n    )\n  }\n  \n  #read the crypto csv\n  crypto <- read.csv(\"crypto_final_usd.csv\")\n  # change in to date format\n  crypto$Date <- as.Date(crypto$Date, format = \"%m/%d/%y %H:%M\")\n  #omit the na values\n  crypto <- na.omit(crypto)\n  \n  #read the coin name\n  coin <- reactive({\n    paste(input$coin, input$hlc, sep = \".\")\n  })\n  \n  #calculate the returns\n  returns <-\n    reactive({\n      log(crypto[, eval(coin())][-1] / crypto[, eval(coin())][-length(crypto[, eval(coin())])])\n    })\n  n <- reactive({\n    length(returns())\n  })\n  #calculate the upper limit for the mean CI\n  ci <- reactive({\n    qt(input$ci / 200 + 0.5, n() - 1) * sd(returns()) / sqrt(n())\n  })\n  #upper limit for var CI\n  up <- reactive({\n    qchisq((1 - (100 - input$ci) / 200), n() - 1)\n  })\n  #lower limit for the var CI\n  down <- reactive({\n    qchisq((100 - input$ci) / 200, n() - 1)\n  })\n  #create the qqplot to check if dist is normal\n  output$qqplot <- renderPlotly({\n    y <- quantile(returns(), c(0.25, 0.75))\n    x <- qnorm(c(0.25, 0.75))\n    slope <- diff(y) / diff(x)\n    int <- y[1L] - slope * x[1L]\n    d <- data.frame(resids = returns())\n    p <-\n      ggplot(d, aes(sample = resids)) + stat_qq() + geom_abline(slope = slope, intercept = int)\n    ggplotly(p)\n  })\n  #create the hstogram and plot a normal dist\n  output$plot <- renderPlotly({\n    x <- returns()\n    fit <- dnorm(x, mean = mean(x), sd = sd(x))\n    xbins <- compute_bins(x, input$bins)\n    plot_ly(x = x) %>%\n      add_histogram(xbins = xbins, name = \"Histogram\") %>%\n      add_lines(y = fit,\n                color = \"tozeroy\",\n                name = \"Normal\") %>%\n      layout(yaxis = list(overlaying = \"y\", side = \"left\"))\n  })\n  #calculate the CI for mean\n  output$cim <- renderPrint({\n    as.symbol(paste(\"(\",\n                    mean(returns()) - ci(),\n                    \",\",\n                    mean(returns()) + ci(),\n                    \")\"))\n  })\n  #calculate the CI for var\n  output$civ <- renderPrint({\n    as.symbol(paste(\n      input$ci,\n      \"(\",\n      var(returns()) * (n() - 1) / down(),\n      \",\",\n      var(returns()) * (n() - 1) / up(),\n      \")\"\n    ))\n  })\n  #regression wrt time\n  regtime <- reactive({\n    dates <- crypto$Date[2:length(crypto$Date)]\n    lm(returns() ~ dates)\n  })\n  #calculate the intercept\n  output$intercept <-\n    renderPrint(as.symbol(summary(regtime())$coefficients[1]))\n  #calculate the slope\n  output$slope <-\n    renderPrint(as.symbol(summary(regtime())$coefficients[2]))\n  #r-square\n  output$r2 <- renderPrint(as.symbol(summary(regtime())$r.squared))\n  #plot the residual graph\n  output$residue1 <- renderPlotly({\n    dates <- crypto$Date[2:length(crypto$Date)]\n    fit <- density(summary(regtime())$residuals)\n    plot_ly(x = ~ dates) %>%\n      add_lines(\n        x = fit$x,\n        y = fit$y,\n        fill = \"tozeroy\",\n        line = list(color = \"#5E88FC\")\n      )\n  })\n  #plot regression\n  output$regression <- renderPlotly({\n    dates <- crypto$Date[2:length(crypto$Date)]\n    regtime <- lm(returns() ~ dates)\n    plot_ly(x = ~ dates) %>%\n      add_markers(\n        y = ~ returns(),\n        showlegend = TRUE,\n        name = \"Actual Return\",\n        marker = list(size = 5,\n                      color = 'rgba(255, 100, 193, 1)')\n      ) %>%\n      add_lines(\n        y =  ~ fitted(regtime),\n        line = list(color = '#07A4B5'),\n        name = \"Estimated Return\",\n        showlegend = TRUE\n      ) %>%\n      layout(\n        yaxis = list(zeroline = FALSE, title = \"Log Returns\"),\n        xaxis = list(zeroline = FALSE, title = \"Date\")\n      )\n  })\n  #read currency 1\n  currency1 <- reactive({\n    paste(input$currency1, \"Close\", sep = \".\")\n  })\n  #read currency 2\n  currency2 <- reactive({\n    paste(input$currency2, \"Close\", sep = \".\")\n  })\n  #calculate return for currency 1\n  returns1 <-\n    reactive({\n      log(crypto[, eval(currency1())][-1] / crypto[, eval(currency1())][-length(crypto[, eval(currency1())])])\n    })\n  #calculate return for currency 2\n  returns2 <-\n    reactive({\n      log(crypto[, eval(currency2())][-1] / crypto[, eval(currency2())][-length(crypto[, eval(currency2())])])\n    })\n  #perform the t test\n  output$ttest <- renderPrint({\n    p <- t.test(returns1(), returns2())$p.val\n    if (p > (1 - (input$ci2 / 100))) {\n      as.symbol(\"Means are Equal\")\n    }\n    else{\n      as.symbol(\"Means are Unequal\")\n    }\n  })\n  #regress 2nd returns on the first\n  reg2 <- reactive({\n    lm(returns1() ~ returns2())\n  })\n  #calculate the intercept\n  output$intercept2 <-\n    renderPrint(as.symbol(summary(reg2())$coefficients[1]))\n  #slope\n  output$slope2 <-\n    renderPrint(as.symbol(summary(reg2())$coefficients[2]))\n  #rsquared\n  output$r22 <- renderPrint(as.symbol(summary(reg2())$r.squared))\n  #residuals\n  output$residue2 <- renderPlotly({\n    fit <- density(summary(reg2())$residuals)\n    plot_ly(x = ~ returns2()) %>%\n      add_lines(\n        x = fit$x,\n        y = fit$y,\n        fill = \"tozeroy\",\n        line = list(color = \"#5E88FC\")\n      )\n  })\n  #plot the regression\n  output$regression2 <- renderPlotly({\n    reg2 <- lm(returns1() ~ returns2())\n    plot_ly(x = ~ returns2()) %>%\n      add_markers(\n        y = ~ returns1(),\n        showlegend = TRUE,\n        name = \"Actual FX2 Return\",\n        marker = list(size = 5,\n                      color = 'rgba(255, 100, 193, 1)')\n      ) %>%\n      add_lines(\n        y =  ~ fitted(reg2),\n        line = list(color = '#07A4B5'),\n        name = \"Estimated FX2 Return\",\n        showlegend = TRUE\n      ) %>%\n      layout(\n        yaxis = list(zeroline = FALSE, title = \"1st FX pair Returns\"),\n        xaxis = list(zeroline = FALSE, title = \"2nd FX pair Returns\")\n      )\n  })\n  currency3 <- reactive({\n    paste(input$currency3, \"Close\", sep = \".\")\n  })\n  #regression on market value\n  regm <- reactive({\n    lm(market[, eval(currency3())] ~ market[, \"market\"])\n  })\n  #calculate the corelation\n  output$corrm <-\n    renderPrint(as.symbol(cor(market[, eval(currency3())], market[, \"market\"])))\n  output$interceptm <-\n    renderPrint(as.symbol(summary(regm())$coefficients[1]))\n  output$slopem <-\n    renderPrint(as.symbol(summary(regm())$coefficients[2]))\n  output$r2m <- renderPrint(as.symbol(summary(regm())$r.squared))\n  output$residuem <- renderPlotly({\n    fit <- density(summary(regm())$residuals)\n    plot_ly(x = ~ market[, \"market\"]) %>%\n      add_lines(\n        x = fit$x,\n        y = fit$y,\n        fill = \"tozeroy\",\n        line = list(color = \"#5E88FC\")\n      )\n  })\n  output$regressionm <- renderPlotly({\n    regm <- lm(market[, eval(currency3())] ~ market[, \"market\"])\n    plot_ly(x = ~ market[, \"market\"]) %>%\n      add_markers(\n        y = ~ market[, eval(currency3())],\n        showlegend = TRUE,\n        name = \"Actual FX Value\",\n        marker = list(size = 5,\n                      color = 'rgba(255, 100, 193, 1)')\n      ) %>%\n      add_lines(\n        y =  ~ fitted(regm),\n        line = list(color = '#07A4B5'),\n        name = \"Estimated FX Value\",\n        showlegend = TRUE\n      ) %>%\n      layout(\n        yaxis = list(zeroline = FALSE, title = \"FX Value\"),\n        xaxis = list(zeroline = FALSE, title = \"Market Value\")\n      )\n  })\n}\n",
    "created" : 1512481004891.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1864638645",
    "id" : "F5C3B3CE",
    "lastKnownWriteTime" : 1512481078,
    "last_content_update" : 1512481078790,
    "path" : "~/Desktop/prob project/Users/salilvaidya/Desktop/prob project/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}